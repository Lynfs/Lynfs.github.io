<!DOCTYPE html>
<html>
<style>

		body {
			max-width: 50em;
			margin: 0 auto;
			margin-top: 3em;
		}
		pre {
			white-space: pre-wrap;
			line-height: 125%;
		}
		@media only screen and (max-width:768px) {
			body {
				max-width:100%;
			}
		}
		td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
		span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
		td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
		span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
		.codehilite .hll { background-color: #ffffcc }
		.codehilite { background: #f8f8f8; }
		.codehilite .c { color: #408080; font-style: italic } /* Comment */
		.codehilite .err { border: 1px solid #FF0000 } /* Error */
		.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
		.codehilite .o { color: #666666 } /* Operator */
		.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
		.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
		.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
		.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
		.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
		.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
		.codehilite .gd { color: #A00000 } /* Generic.Deleted */
		.codehilite .ge { font-style: italic } /* Generic.Emph */
		.codehilite .gr { color: #FF0000 } /* Generic.Error */
		.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
		.codehilite .gi { color: #00A000 } /* Generic.Inserted */
		.codehilite .go { color: #888888 } /* Generic.Output */
		.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
		.codehilite .gs { font-weight: bold } /* Generic.Strong */
		.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
		.codehilite .gt { color: #0044DD } /* Generic.Traceback */
		.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
		.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
		.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
		.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
		.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
		.codehilite .kt { color: #B00040 } /* Keyword.Type */
		.codehilite .m { color: #666666 } /* Literal.Number */
		.codehilite .s { color: #BA2121 } /* Literal.String */
		.codehilite .na { color: #7D9029 } /* Name.Attribute */
		.codehilite .nb { color: #008000 } /* Name.Builtin */
		.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
		.codehilite .no { color: #880000 } /* Name.Constant */
		.codehilite .nd { color: #AA22FF } /* Name.Decorator */
		.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
		.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
		.codehilite .nf { color: #0000FF } /* Name.Function */
		.codehilite .nl { color: #A0A000 } /* Name.Label */
		.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
		.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
		.codehilite .nv { color: #19177C } /* Name.Variable */
		.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
		.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
		.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
		.codehilite .mf { color: #666666 } /* Literal.Number.Float */
		.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
		.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
		.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
		.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
		.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
		.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
		.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
		.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
		.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
		.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
		.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
		.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
		.codehilite .sx { color: #008000 } /* Literal.String.Other */
		.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
		.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
		.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
		.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
		.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
		.codehilite .vc { color: #19177C } /* Name.Variable.Class */
		.codehilite .vg { color: #19177C } /* Name.Variable.Global */
		.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
		.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
		.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */

	
</style>
<head>
  <meta charset="UTF-8">
</head>

<body><p>﻿---
layout: post
category: example2</p>
<hr />
<h1>RSA PARA CURIOSOS</h1>
<p>Ao pesquisarmos sobre algoritmos de criptografia, com certa frequência nos deparamos com o famoso <em>"Algoritmo de Rivest-Shamir-Adleman"</em>, ou, para os intimos, RSA. Mas, o que seria, como funciona e qual a garantia que temos de que esse algoritmo é realmente seguro? Essas são as perguntas que pretendo dissecar no derrorer desta publicação.</p>
<p>Antes de prossegirmos, recomendo a leitura da publicação sobre <a href="[https://deadlock.team/wtf/2019/01/23/Diffie-Hellman/](https://deadlock.team/wtf/2019/01/23/Diffie-Hellman/)">diffie-hellman</a> no site do time qual faço parte, onde algumas dúvidas que podem surgir ao decorrer desta leitura são esclarecidas,
tais como o funcionamento de chaves simétricas e assimétricas.</p>
<p>Dito isso, prossigamos com algumas explicações necessárias e antecedentes ao algoritmo em si. Essas explicações servem para o esclarecimento dos processos envolvidos no decorrer da realização de criptografia de um conteúdo qualquer.</p>
<h2>Teorema fundamental da aritmética</h2>
<p>O <strong>Teorema Fundamental da Aritmética</strong> sustenta que:</p>
<p>Se <strong>n</strong> é um número natural, <strong>n&gt;1</strong>, então existem números primos <strong>p1,p2,p3,⋯,pr</strong>, com <strong>r≥1</strong>, tais que:
    <strong>n=p1p2p3⋯pr.</strong></p>
<p>A menos da ordem dos fatores primos, essa representação é única. Vejamos:</p>
<p>Sendo <strong>x</strong> um número qualquer, queremos provar que existe uma decomposição de x em fatores primos. Para isso, usaremos um recurso indutivo:<br />
-   Começando com <strong>x=2</strong>, vemos que ele possui uma decomposição em fatores primos, já que ele próprio é um número primo, e podemos chamar essa decomposição de  <strong>decomposição trivial</strong>.
-   Sendo <strong>x &gt; 2</strong>, se <strong>x</strong> for um número primo, então admite a decomposição trivial, da mesma forma que o número 2. Se x não for primo, então <strong>x</strong> possui um divisor positivo d qualquer, tal que <strong>x=dq</strong>. De forma análoga ao que foi feito com <strong>x</strong>, caso <em>d</em> ou <em>q</em> sejam primos, eles admitem decomposição trivial. </p>
<p>Uma vez provada a existência da decomposição, devemos provar que essa é única:<br />
Vamos supor que o número <strong>x</strong> admite duas decomposições em primos, de modo que <em>x = p1 e x = q1q2...qs</em> . Chamaremos s de comprimento de x.<br />
Então  <em>p1 = q1q2...qs</em> como <em>q1 divide  q1q2...qs, q1</em> divide <em>p1</em>  e  <em>p1</em> é primo, devemos ter  <em>p1 = q1</em>. Cancelando dos dois lados da igualdade, teremos  <em>1 = q2...qs</em>. Assim, vemos que  <em>s = 1</em>, pois se  <em>s&gt;1</em>, teríamos um produto de números primos resultado em 1, o que é um absurdo.<br />
Assim, todo o número de comprimento 1 admite uma única decomposição.<br />
Agora, suponha que, para algum k natural, números de comprimento k admita uma única decomposição. Sendo x tal que  <em>x = pqp2...pk pk+1 = q1q2...qs</em>, em que os fatores estão dispostos em ordem crescente, provemos que números de comprimento  <em>K=1</em> admitem uma única decomposição.<br />
<em>q1</em>  divide  <em>p1p2...pk+1</em>, então  q1  divide algum  <em>Pi</em>. Como ambos são primos, qi = pi  , e sabemos que  <em>q1 ≥ p1</em>, pois os números estão em ordem crescente. Da mesma forma,  <em>p1</em> divide <em>q1q2...qs</em>, então <em>p1 = qj</em>, para algum <strong>j</strong>.<br />
Desse modo, _ p1 ≥ q1_. Cancelando os dois valores na igualdade, teremos que <em>p2...pk+1 = qs...qs </em>.<br />
Temos, assim, um número de comprimento  <em>k(p2...pk+1)</em>, que, pela hipótese de indução, possui uma única decomposição.<br />
Visualmente, temos:<br />
<img alt="enter image description here" src="http://clubes.obmep.org.br/blog/wp-content/uploads/2015/11/primos2.png" /><img alt="enter image description here" src="http://clubes.obmep.org.br/blog/wp-content/uploads/2015/11/primos1.png" />  </p>
<h2>Os números primos</h2>
<p>Um número é classificado como primo se ele é maior do que um e é divisível apenas por um e por ele mesmo. Apenas números naturais são classificados como primos.<br />
Eliminando alguns números com as seguintes regras de divisibilidade:<br />
<strong>Divisibilidade por 2:</strong> todo número par é divisível por 2. Os números pares são aqueles terminados em 0, 2, 4, 6 e 8.<br />
<strong>Divisibilidade por 3</strong>: um número é divisível por 3 se a soma dos seus algarismos der um número divisível por 3.<br />
<strong>Divisibilidade por 4</strong>: um número é divisível por 4 se ele for divisível duas vezes por 2 ou, então, se seus dois últimos algarismos forem divisíveis por 4.<br />
<strong>Divisibilidade por 5</strong>: todo número terminado em 0 ou 5 é divisível por cinco.<br />
<strong>Divisibilidade por 6:</strong>  se um número for par e também divisível por 3, será divisível por 6.<br />
<strong>Divisibilidade por 7:</strong>  um número é divisível por 7 se a diferença entre o dobro do último algarismo e o restante do número resultar em um número múltiplo de 7.<br />
teremos, para N numeros primos onde N&lt;100:<br />
<img alt="crivo" src="https://s1.static.brasilescola.uol.com.br/img/2015/11/numeros-primos-.jpg" /><br />
onde os números destacados em amarelo não se enquadram nas regras de divisibilidade supracitadas.  </p>
<h2>Aritmética modular e relação de congruências</h2>
<p>Uma congruência é a relação entre dois números que, divididos por um terceiro - chamado módulo de congruência - deixam o mesmo resto. Por exemplo, <em>32</em> é congruente com <em>8</em> módulo <em>12 (32 = 2 x 12 + 8 e 32 = 0 x 12 + 8).</em> <br />
Sejam <strong>a</strong> e <strong>b</strong> dois inteiros, e <strong>m</strong> um inteiro positivo. Então <strong>a ≡ b (mod m)</strong> se e somente se <strong>a mod m = b mod m</strong>.<br />
Ex: <em>379 ≡ 3 (mod 8)</em>    </p>
<h2>O Algoritmo de criptografia RSA</h2>
<p>O Algoritmo de rsa é um algoritmo de criptografia assimétrica e toma como base a matemática dos números primos. Vejamos:<br />
1.  Escolhe-se dois números primos <strong>p</strong> e <strong>q</strong>, distintos entre si.
2. Define-se <em>N = pq e φ(N) = (p - 1) (q - 1)</em>.
3. Deve-se escolher um número <em>e</em>, que faz parte da chave pública, de forma que <em>MDC( e, φ(N) ) = 1</em>: <em>( e,φ(N) ) = 1, e 1 &lt; e &lt; φ(N)</em>.
4. Resolvendo a congruência <em>ed ≡ 1 ( mod φ(N) )</em> encontra-se <em>d</em>, que faz parte da chave privada.
5. De acordo com uma tabela rpé formulada e de domínio público( como a tabela ASCII), é feita a transformação de todos os caracteres da mensagem em números, obtendo-se a mensagem numérica em um único bloco que será dividida em blocos <em>b</em>, de forma que:  <em>1 ≤ b &lt; N</em>. Isso garante que, ao utilizar congruência, obtenha-se um único resultado na decodificação.
6. De posse da Chave Pública (e,N) criptografa-se os blocos <em>b</em> de acordo com a congruência (b^e) ≡ C(b) (mod N) onde C(b) é a mensagem criptografada.
7. De posse da chave privada (d, N) descriptografa-se de acordo com a congruência: <em>C(b)^d ≡ D(C(b)) (mod N)</em>, onde <em>D(c(b))</em> é a mensagem descriptografada, <em>1 ≤ D(C(b)) &lt; N.</em>
8. Cada bloco D(C(b)) deve ser colocado em sequência e de acordo com a mesma tabela usada na <strong>5</strong> parte desta sequência  os números devem ser convertidos em caracteres.<br />
Vejamos um exemplo para φ(697):<br />
<em>φ(n) = (<strong>p</strong> - 1)  (<strong>q</strong> - 1)</em><br />
<em>φ(697) = (<strong>17</strong> - 1) * (<strong>41</strong> - 1)</em><br />
<em>φ(697) = <strong>640</strong></em><br />
<em>logo</em>:<br />
<em>MDC(640, 3) = 1</em> e a <em>Chave pública = (697, 13).</em><br />
<em>Para "TURING" teremos:</em><br />
<em>T = 19 ^ 13 mod 697</em><br />
<em>U = 20 ^ 13 mod 697</em><br />
<em>R = 17 ^ 13 mod 697</em><br />
<em>I = 09 ^ 13 mod 697</em><br />
<em>N = 13 ^ 13 mod 697</em><br />
<em>G = 07 ^ 13 mod 697</em><br />
Que resulta em:<br />
<code>15 692 391 501 421 176</code>   </p>
<h2>Mas, por que esse método funciona?</h2>
<p>A Mensagem b deve ser igual à mensagem decodificada <em>D(C(b))</em> de acordo com o processo:<br />
<em>(b^e)^ ≡ C(b) mod N</em><br />
<em>C(b)^d ≡D(C(b)) mod N</em><br />
<em>ed ≡ 1 mod φ(N)</em><br />
Como <em>b &lt; N D(C(b)) &lt; N</em> temos que:<br />
(b^e)^d^ ≡ D(C(b)) mod N. E, se p | b implica que <em>b≡0 mod p</em>, então b^e^d^≡ 0 mod p, implicando assim que <em>b^e^d^≡ b mod p, provando que:<br />
_D(C(b)) ≡b mod p</em><br />
O que implica <em>(b^(q-1))^(p-1)^ ≡ 1^(p-1) mod q</em>, que, por transitividade, obtem-se que <em>b ≡D(C(b)) mod N.</em> Logo, a mensagem <strong>b</strong> é igual à mensagem decodificada <em>D(C(b))</em>.  </p>
<h2>Por que é seguro?</h2>
<p>Para quebrar o código é preciso ter a chave de decodificação <em>(d, N)</em>, acontece que a dhace pública <em>(e, N)</em> já fornece parte do que é preciso, a saber, o número N. Assim, é apenas preciso encontrar <em>d</em> e ter a mensagem em mãos.<br />
Tendo em vista o  número  <em>N = pq e φ(N) = (p - 1) (q - 1)</em>, é preciso encontrar a fatoração de N para que <em>p e q</em> sejam encontrrados e assim encontrar φ(N), para prosseguir com <em>ed≡1 mod φ(N)</em> e por fim <strong>d</strong>, o que é inviável haja vista a incapacidade computacional para fatoração de Inteiros grandes sem pequenos fatores.<br />
Se uma chave possui 3 bits, com <strong>n</strong> teremos <em>k = 2^n</em> podemos dizer que k = 2^3^, que é a quantidade de possibilidades da representação binária elevada à quantidade de bits. Nesse caso teremos 8 possibilidades: <strong>000, 001, 010, 011, 100, 101, 110, 111</strong>. Assim sendo, a cada bit acrescentado ao expoente, dobra-se a quantidade de combinações possíveis e, consequentemente, esforço computacional e tempo requeridos para exaurimento das possibilidades.<br />
Em uma situação onde tivéssemos uma chave de 256 bits, ou, k= 2^256 para n=256, e um computador capaz de realizar 33.86 petaflops (quadrilhões de calculos por segundo), teriamos a seguinte situação:<br />
1 Petaflot = 2^50 operações por segundo.  Logo, nosso supercomputador pode processar <em>33.86 x 2^50</em> operações por segundo, o que nos resulta em:<br />
2^256^ / (3386x2^50) x 350 x 24 x 60 x 60, que resulta em 9.63x10^52 anos.<br />
Deixo à sua imaginação a tarefa de imaginar o número de possibilidades/tempo para k = 2^4096^.  </p>
<h2>Referências</h2>
<p><a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg">Criptografia RSA, por Daniele Helena Bonfim</a><br />
<a href="https://www.amsi.org.au/teacher_modules/pdfs/Maths_delivers/Encryption5.pdf">A guide for teachers – Years 11 and 12 b y Maths delivers! RSA Encryption</a><br />
<a href="https://pt.wikipedia.org/wiki/Teorema_fundamental_da_aritm%C3%A9tica">Teorema_fundamental_da_aritmética</a><br />
<a href="https://www.cin.ufpe.br/~gdcc/matdis/aulas/aritmeticaModular.pdf">Introdução a aritmetica Modular</a>  </p></body><hr>by You</html>