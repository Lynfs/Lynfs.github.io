<!DOCTYPE html>
<html>
<style>

		@font-face { font-family: "gohu"; src: url("/gohu.woff") format('woff'); }
		body {
			font-family: 'gohu', monospace;
			max-width: 50em;
			margin: 0 auto;
			color: white;
			background: black;
			line-height: calc(1ex / 0.32);
			margin-top: 3em;
		}
		pre {
			font-family: 'gohu', monospace;
			white-space: pre-wrap;
			line-height: 125%;
      background-color: #111;
      padding: 1em;
		}
		@media only screen and (max-width:768px) {
			body {
				max-width:100%;
			}
		}
		a:link {
			color: #0a0 ;
		}
		a:visited {
			color: #004100 ;
		}
		td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
		span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
		td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
		span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
		.codehilite .hll { background-color: #0000ff }
		.codehilite { background: #000000; }
		.codehilite .c { color: #00ff00 } /* Comment */
		.codehilite .k { color: #ff0000 } /* Keyword */
		.codehilite .ch { color: #00ff00 } /* Comment.Hashbang */
		.codehilite .cm { color: #00ff00 } /* Comment.Multiline */
		.codehilite .cp { color: #e5e5e5 } /* Comment.Preproc */
		.codehilite .cpf { color: #00ff00 } /* Comment.PreprocFile */
		.codehilite .c1 { color: #00ff00 } /* Comment.Single */
		.codehilite .cs { color: #00ff00 } /* Comment.Special */
		.codehilite .kc { color: #ff0000 } /* Keyword.Constant */
		.codehilite .kd { color: #ff0000 } /* Keyword.Declaration */
		.codehilite .kn { color: #ff0000 } /* Keyword.Namespace */
		.codehilite .kp { color: #ff0000 } /* Keyword.Pseudo */
		.codehilite .kr { color: #ff0000 } /* Keyword.Reserved */
		.codehilite .kt { color: #ee82ee } /* Keyword.Type */
		.codehilite .s { color: #87ceeb } /* Literal.String */
		.codehilite .no { color: #7fffd4 } /* Name.Constant */
		.codehilite .nf { color: #ffff00 } /* Name.Function */
		.codehilite .nv { color: #eedd82 } /* Name.Variable */
		.codehilite .sa { color: #87ceeb } /* Literal.String.Affix */
		.codehilite .sb { color: #87ceeb } /* Literal.String.Backtick */
		.codehilite .sc { color: #87ceeb } /* Literal.String.Char */
		.codehilite .dl { color: #87ceeb } /* Literal.String.Delimiter */
		.codehilite .sd { color: #87ceeb } /* Literal.String.Doc */
		.codehilite .s2 { color: #87ceeb } /* Literal.String.Double */
		.codehilite .se { color: #87ceeb } /* Literal.String.Escape */
		.codehilite .sh { color: #87ceeb } /* Literal.String.Heredoc */
		.codehilite .si { color: #87ceeb } /* Literal.String.Interpol */
		.codehilite .sx { color: #87ceeb } /* Literal.String.Other */
		.codehilite .sr { color: #87ceeb } /* Literal.String.Regex */
		.codehilite .s1 { color: #87ceeb } /* Literal.String.Single */
		.codehilite .ss { color: #87ceeb } /* Literal.String.Symbol */
		.codehilite .fm { color: #ffff00 } /* Name.Function.Magic */
		.codehilite .vc { color: #eedd82 } /* Name.Variable.Class */
		.codehilite .vg { color: #eedd82 } /* Name.Variable.Global */
		.codehilite .vi { color: #eedd82 } /* Name.Variable.Instance */
		.codehilite .vm { color: #eedd82 } /* Name.Variable.Magic */
	
</style>
<head>
  <meta charset="UTF-8">
</head>

<body><h1>Criptografia de curva elíptica para curiosos</h1>
<p>Como bem sabemos, os algoritmos criptográficos atuais são, em essência, problemas matemáticos difíceis de resolver, e  a única forma de quebrar esse tipo de sistema é por intermédio de alguns outros algoritmos que tentem resolver, da forma mais eficiente possível, o problema proposto.</p>
<p>A criptografia de curva elíptica, utilizada em serviços como <em>TLS</em>, <em>SSH</em> e <em>PGP</em>, aparece como uma abordagem proposta na criação de algoritmos criptográficos assimétricos, utilizando de um conceito matemático chamado <strong>Curva Elíptica</strong>(dãã).</p>
<p>À título de exemplo, no RSA, a chave pública é um grande número, que é um produto de dois números primos também grandes, além de um outro número menor e importante, e a chave privada é um outro número relacionado com os primeiros citados.<a href="https://lynfs.github.io/Rsa-para-Curiosos">(clique aqui para uma melhor compreensão)</a>. Em ECC (elliptc-curve cryptography), a chave pública é uma <strong>equação para uma curva elíptica</strong> e um ponto que reside naquela curva, e a chave privada é um número também relacionado.</p>
<p>Porém, antes de qualquer aprofundamento, comecemos do princípio... O que são curvas elípticas, qual sua aplicação na criptografia e por quê funciona? É o que pretendo explicar, de maneira breve e não tão técnica nos escritos à seguir. Como meu conhecimento não é aprofundado, me limito à explicar o que sei, podendo gerar uma nova postagem se necessário aprofundar mais à teoria que envolve o assunto. </p>
<p>Dito isso, vejamos como essas curvas funcionam...</p>
<h2>Cuvas elípticas e relações algébricas</h2>
<p><img alt="enter image description here" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/ECClines.svg/1920px-ECClines.svg.png" /></p>
<p>O estudo das curvas elípticas é uma área da <em>Geometria Algébrica</em> com aplicações em <em>Teoria dos Números</em>, e se definem mediante equações cúbicas (de terceiro grau). Essas curvas são conhecidas como curvas <strong>não-singulares</strong>, que em outras palavras significa que não possuem auto-intersecções, e se pode definir uma operação binária para o conjunto de seus pontos de uma maneira geométrica natural.</p>
<p>Ou, de maneira simplificada, é um conjunto de pontos que satisfaz a equação *y² = x³+ ax + b.</p>
<p>Essa equação representa uma curva especial matemática, sobre qual podemos definir algumas operações especiais..</p>
<p>Adentremos na matemática um pouco para compreender esse assunto em termos matemáticos.</p>
<p>Definiremos a soma de dois pontos <em>P</em> e <em>Q</em> de uma curva elíptica <em>E</em> da seguinte forma:</p>
<ul>
<li>Trace uma reta que conecta os dois pontos <em>P e Q</em></li>
<li>Essa reta vai tocar na curva em um ponto definido <em>-R</em></li>
<li>Espelhando o ponto <em>-R</em> em torno do eixo <em>X</em>, encontramos um ponto <em>R</em> pertencente à curva, o qual é o resultado da soma de <em>P+Q = R</em></li>
</ul>
<p><img alt="" src="https://www.researchgate.net/profile/Tabassum-Ara-2/publication/326009351/figure/fig1/AS:642029855977473@1530083254406/Point-Addition-on-the-Elliptic-Curve-18.png" /></p>
<p>mostra-se ainda que uma operação de soma assim definida sobre pontos de uma curva elíptica forma um <strong>Grupo Abeliano</strong>, que significa:</p>
<ul>
<li>Existe um elemento neutro</li>
<li>Todo elemento admite um inverso</li>
<li>A soma é aditiva e comutativa</li>
</ul>
<h2>Campos finitos Fp</h2>
<p>Um campo finito é um <em>conjunto</em> composto por um número finito de elementos. Simples assim!</p>
<p>Já campos finitos <em>Fp</em> é um <em>conjunto</em> de números inteiros módulos <em>p</em>, onde <em>p</em> é um número primo. O conjunto de inteiros módulo <em>p</em> consiste em todos os números inteiros de 0 até <em>p-1</em> e suas operações são feitas em aritmética modular(checar post sobre RSA para maior entendimento).</p>
<p>Recaptulemos...</p>
<p>ex. <em>a ≡ b mod n</em> é o mesmo que dizer que "O resto da divisão de <em>b</em> por <em>n</em> = a"</p>
<h2>Curvas elípticas sobre Fp</h2>
<p>São o conjunto de <em>(x,y)</em> que satisfazem a equação:</p>
<p><em>y² mod p = x³ + ax + b mod p</em>, com  4a³+27b ≠ 0, tal que <em>a, b, x e y</em> pertencem a Fp mais um ponto especial chamado de ponto infinito <em>O</em>.</p>
<p>No nosso caso criptográfico, é escolhido um ponto base <em>G</em>, que possui uma ordem <em>n</em> e um cofator <em>h</em>.</p>
<p>Abaixo, exemplos de curvas elípticas sobre Fp para  p = 19, 97, 127 e 148.</p>
<p><img alt="enter image description here" src="https://miro.medium.com/max/1216/0*7cfE3-WGOzLAI8EP.png" /></p>
<p>E podemos ver que, quanto maior o primo, maior o números de pontos na curva elíptica, o que é muito bacana, porque quando vamos criptografar uma mensagem, precisamos mapear a mensagem em algum ponto de uma curva elíptica, então quanto mais pontos, melhor.</p>
<h2>Chaves assimétricas sobre curvas elípticas</h2>
<ul>
<li>Privada<ul>
<li>define-se <em>d</em>, um inteiro randômico qualquer entre 1 e n-1, onde n é a ordem do ponto base G.</li>
</ul>
</li>
<li>Pública<ul>
<li>um ponto D = dG</li>
</ul>
</li>
</ul>
<h2>sistema de ElGamal</h2>
<p>O fluxo de cifragem C segue o processo onde, usamos a chave privada <em>d</em> do emissor, a chave pública <em>D</em> do receptor,  aplica-se o algoritmo de curva elíptica e obtemos a saída criptografada.</p>
<p><strong>C = M+d[e]D[r]</strong>, onde definimos M como a mensagem mapeada em um ponto sobre a curva.</p>
<p>Já no fluxo de descriptografia, o receptor recebe a mensagem criptografada C, e a descriptografa utilizando a sua chave privada e a pública do emissor.</p>
<p><strong>M = C - d[r]D[e]</strong></p>
<h2>Protocolo Diffie-hellman sobre curvas elípticas</h2>
<p>No caso do sistema diffie-hellman, teremos a seguinte linha construtiva:</p>
<p>Nesse sistema, uma pessoa de confiança torna público um número primo <em>P</em> e um inteiro <em>G</em>. Agora, imaginemos que Ana e Bob querem trocar informações utilizando desse sistema para criptografar as mensagens.</p>
<p>Ana e Bob escolhem, cada um, um inteiro <strong>X</strong> qualquer conhecido apenas por cada um deles. Ana e Bob calculam valores congruentes à <em>G</em> elevado aos seus números secretos, e enviam um ao outro.</p>
<p>Ana calcula A ≡ G^x (mod p) e envia para Bob</p>
<p>Bob calcula B ≡ G^x (mod p) e envia para Ana</p>
<p>por fim, com os novos números, eles calculam o resultado da congruência com <em>G</em> elevado aos expoentes secretos</p>
<p>Ana calcula M ≡ B^x (mod p)</p>
<p>Bob calcula M ≡ A^x (mod p)</p>
<p>Mostra-se que os valores de M encontrados por Bob e Ana, na verdade, são iguais. Isto é, eles possuem uma mensagem secreta compartilhada entre eles, mas ainda vemos que para alguem que não tem acesso aos inteiros secretos de Bob e Ana, é matemáticamente difícil descobrir quais são, e, mais ainda, qual é a mensagem criptografada.</p>
<hr />
<p>No caso deste sistema aplicado às curvas elípticas, teremos um seguinte fluxo:</p>
<p>Seja conhecida uma curva elíptica <em>E</em>, um primo <em>p</em> e um ponto P ∈ E, ana e bob escolhem inteiros randômicos secretos e calculam o produto desse inteiro pelo ponto <em>P</em> e em seguida trocam entre si o resultado.</p>
<p>Ana escolhe n[a], calcula Q[a] = n[a]P, e envia para Bob</p>
<p>Bob escolhe n[b], calcula Q[b] = n[b]P, e envia para Ana</p>
<p>Com os novos números, eles repetem o primeiro passo:</p>
<p>Ana calcula Q1 = n[a]Q[b]</p>
<p>Bob calcula Q2 = n[b]Q[a]</p>
<p>Podemos provar que estes números resultantes são iguais (como era de se esperar).</p>
<h2>Escolha das curvas elípticas</h2>
<p>Algumas curvas elípticas tem um nível de segurança menor que outras. É preciso calcular os diferentes parâmetros dela e analizar suas propriedades para garantir sua segurança. E, para que isso não seja sempre necessário, já existem curvas definidas com propriedades interessantes e são consideradas seguras, e são definidas por institutos como NIST FIPS PUB 186-3-DSS e SECG em SEC2, como a curva ecp256k1.</p>
<p>Existem também algoritmos como ECDSA que é o algoritmo de assinaturas digitais, que permite verificação de autenticidade do emissor através do conhecimento de sua chave pública, ou ECDH que é o protocolo de acordo de chaves Diffie-hellman com curvas elípticas.</p>
<h3>Problemática do logaritmo discreto para curvas elípticas</h3>
<p>Nesse momento, surge a dúvida: quem garante que isso funciona?
Existe um problema que garante que a segurança das curvas elípticas não será facilmente violado, e é o problema dos logaritmos discretos. 
Esse problema consiste na seguinte premissa:</p>
<p>"Dados dois números <em>p e q</em>, encontrar K tal que q = KP</p>
<p>Ou, no caso do campo finito Fp, conhecidos <em>a e b</em>, encontrar k tal que b = a^k mod p."</p>
<p>Para os problemas citados acima, é crível que não há um algoritmo de tempo polinomial que rode em um computador clássico para resolvê-lo e quebrar todos os algoritmos de criptografia de curvas elípticas, apesar de não existir uma prova matemática para tal afirmação.</p>
<hr />
<h3>Referências</h3>
<ul>
<li><a href="https://periodicos.ufsm.br/cienciaenatura/article/download/14815/pdf">An Introduction to Elliptic Curves with Application for Secondary Education</a></li>
<li><a href="https://www.lncc.br/~borges/doc/Curvas%20Elipticas%20-%20Aplicacao%20em%20Criptografia%20Assimetrica.pdf">Curvas Elípticas: Aplicação em Criptografia Assimétrica</a></li>
</ul></body><hr>by cnx</html>